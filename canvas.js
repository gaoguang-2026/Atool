
var canvas = (function(canvas) {
	var drawing;
	var Days;

	var emotionPoints = [];   // 保存背离率的点
	var stEmotionPoints = []; // 保存涨停背离率的点
	var szPoints = [];   // 保存sz的点

	var width = 0;
	var height = 0;
	var width_factor = 0.9;
	var height_factor = 0.8;
	var siteX;
	var siteY;
	var siteHeight;
	var siteWidth;
	var cellWidth = 0;
	//var cellHeight;
	var cell_factor = 0.95;
	var winFactor = 0.4;

	var getDayFromDateStr = function(dateStr) {
		if (!Days || !Days.length ) {
			console.error('Days invalid');
		}
		return Days.find((d)=>{
			return Configure.formatExcelDate(d[Configure.title2.date], '') == dateStr;
		});
	};

	var autoGenerateDataFromExl = function(day) {
		var dateArr = workbook.getDateArr((a,b)=>{
				return b - a;
			});
		var dayIndex = dateArr.indexOf(Configure.formatExcelDate(day[Configure.title2.date], ''));
		var predayDate  = dateArr[dayIndex + 1];
		// 连扳数、晋级率   涨停数 跌停数 和炸板率
		if (!day[Configure.title2.erban] || !day[Configure.title2.boardnum]) {
			var param = {
				hotpointArr: [],
				type:5,
				sort:1
			};
			var tickets =  parser.getTickets(dateArr[dayIndex], param);
			var dayNumberTitle = Configure.replaceTitleDate(Configure.title.dayNumber, dateArr[dayIndex]);
			var boardTimeTilte = Configure.replaceTitleDate(Configure.title.boardTime, dateArr[dayIndex]);
			day[Configure.title2.erban] = tickets.filter((t) => {
				return t[dayNumberTitle] == 2;
			}).length;
			day[Configure.title2.lianban] = tickets.filter((t) => {
				return t[dayNumberTitle] >= 2;
			}).length;
			tickets = tickets.sort((a, b)=>{
				return b[dayNumberTitle] - a[dayNumberTitle];
			})
			day[Configure.title2.height] = tickets[0][dayNumberTitle];
			if(predayDate) {
				preDay = getDayFromDateStr(predayDate);
				day[Configure.title2.jinji] = parseFloat((day[Configure.title2.lianban] -  day[Configure.title2.erban]) * 100/
												preDay[Configure.title2.lianban]).toFixed(2);
			}
			// 涨停数、跌停数 和炸板数  亏钱效应
			day[Configure.title2.boardnum] = tickets.filter((t)=>{
				return t[dayNumberTitle] >= 1;
			}).length;
			day[Configure.title2.floornum] = tickets.filter((t)=>{
				return t[dayNumberTitle] == 0 && t[boardTimeTilte] == '--';
			}).length;
			day[Configure.title2.failednum] = tickets.filter((t)=>{
				return t[dayNumberTitle] == 0 && t[boardTimeTilte] != '--';
			}).length;
			day[Configure.title2.failedRate] = ((day[Configure.title2.failednum] + 
						day[Configure.title2.floornum]) / tickets.length).toFixed(2);
			// 资金总量  涨停的总和-跌停的总和
			day[Configure.title2.totalFund] = 0;
			tickets.forEach((ticket)=>{
				if(ticket[dayNumberTitle] >= 1) {
					day[Configure.title2.totalFund] += 
					ticket[Configure.title.realHandoverPercent] * ticket[Configure.title.realValue] / 100;
				} else if(ticket[dayNumberTitle] == 0 && ticket[boardTimeTilte] == '--') {
					day[Configure.title2.totalFund] -= 
						ticket[Configure.title.realHandoverPercent] * ticket[Configure.title.realValue] / 100;
				}
			});
			day[Configure.title2.totalFund] = (day[Configure.title2.totalFund] / 100000000).toFixed(2);   // 亿为单位
			
		}
		
		var calMa5AndBeili = function( ZHISHU_TITLE ,MA5Title,BEILItitle) {
			if(!day[MA5Title]) {
				var sum = parseInt(day[ZHISHU_TITLE]);
				// 当天和过去4天的和
				for(var i = 0; i < 4; i ++) {
					if (dateArr[dayIndex + i + 1]) {
						sum += parseInt(getDayFromDateStr(dateArr[dayIndex + i + 1])[ZHISHU_TITLE]);
					}
				}
				day[MA5Title] = parseInt(sum/5);
				day[BEILItitle] = parseFloat((day[ZHISHU_TITLE] - day[MA5Title]) * 100/
												day[ZHISHU_TITLE]).toFixed(2);
			}
		}
		// 连扳指数 ma5和背离率
		calMa5AndBeili(Configure.ZHISHU_TITLE, Configure.title2.ma5, Configure.title2.beili);
		// 涨停板 MA5 和 背离率
		calMa5AndBeili(Configure.ZHISHU_SUB_TITLE, Configure.title2.subMa5, Configure.title2.subBeili);
		return day;
	};

	var init = function(c, winXfactor = 1) {
		drawing = c;
		Days = workbook.getDatesSheet();
		
		width = c.width * winXfactor;
		height = c.height;

		siteX = width * (1 - width_factor)/2;
		siteY = height * (1 - height_factor)/2;
		siteWidth = width * width_factor;
		siteHeight = height * height_factor;
		
		cellWidth = siteWidth / Days.length *cell_factor;
		
		console.log('canvas width:' + width + 
					' height:' + height + 
					' siteX' + siteX +
					' siteY:' + siteY +
					' siteWidth:' + siteWidth + 
					' siteHeight:' + siteHeight +
					' cellWidth:' + cellWidth);
					
		// 通过parser分析出当天的echelon
		Days.forEach((d)=>{
			var dateStr = Configure.formatExcelDate(d[Configure.title2.date], '');
			if (workbook.sheetExist(dateStr)) {
				autoGenerateDataFromExl(d);
				// Echelons
				d[Configure.title2.echelons] = parser.getEchelons(dateStr);
				// boardHeight
				var objBH = parser.getBoardHeight(dateStr, Configure.title2.BH_Draw_title );
				if (objBH) {
					d[Configure.title2.boardHeight] = objBH.value;
					d[Configure.title2.dragon] = objBH.name;
				}
			} else {
				d[Configure.title2.echelons] = [];
				d[Configure.title2.boardHeight] = 0;
				d[Configure.title2.dragon] = '';
			}
		});
	};

	var drawSite = function(indecatorName, echelonNames) {
		//画线
		var ctx = drawing.getContext("2d");		
		ctx.beginPath();
		ctx.lineWidth="2";
		ctx.strokeStyle = Configure.site_color;
	//	ctx.moveTo(siteX,siteY);
		ctx.moveTo(siteX ,siteY + siteHeight);
		ctx.lineTo(siteX + siteWidth, siteY + siteHeight);
		ctx.lineTo(siteX + siteWidth, siteY);
		ctx.lineTo(siteX,siteY);
		
		// 画日期
		for(i = 0; i < Days.length; i ++) {
			// 日期网格
			var d = new Date(Configure.formatExcelDate(Days[i][Configure.title2.date], '/'));
			if (d.getDay () == 1) {   // 星期一
				ctx.font="14px 楷体";
				ctx.fillStyle = Configure.site_color;
				ctx.fillText(Configure.formatExcelDate(Days[i][Configure.title2.date], '').substr(4,4),
					 siteX + cellWidth  * i, siteY + siteHeight + 20);
					 
				ctx.lineWidth="0.5";
				ctx.strokeStyle = Configure.site_color;
				ctx.moveTo(siteX + cellWidth  * i,siteY);
				ctx.lineTo(siteX + cellWidth  * i,siteY + siteHeight);
			}
			//画大周期
			var cycle = workbook.getEmotionalCycles(Configure.formatExcelDate(Days[i][Configure.title2.date]));
			if (cycle && !!cycle.cycles) {
				ctx.font="14px 楷体";
				ctx.fillStyle = Configure.site_color;
				ctx.fillText(cycle.cycles, siteX + cellWidth  * i, siteY -5);
				
				if (!!cycle.hotpoint) {
					ctx.fillStyle = 'orange';
					ctx.fillText('<' + cycle.hotpoint + '>', siteX + cellWidth  * i + 50, siteY -5);
				}
			}
		};		
		
		// 画0轴
		ctx.lineWidth="0.5";
		ctx.strokeStyle = Configure.site_color;
		ctx.moveTo(siteX,siteY + siteHeight * (1-winFactor));
		ctx.lineTo(siteX + siteWidth,siteY + siteHeight * (1-winFactor));	

		if (echelonNames.length) {
			ctx.fillStyle = Configure.echelon_color[0];
			if (Configure.Echelons_show_type == 'score') {
				ctx.fillText(Configure.Min_echelon_score, siteX + siteWidth + 6, siteY + siteHeight * (1- winFactor));
				ctx.fillText(Configure.Max_echelon_score, siteX + siteWidth, siteY);
			} else {
				ctx.fillText(Configure.Min_echelon_fund, siteX + siteWidth + 6, siteY + siteHeight * (1- winFactor));
				ctx.fillText(Configure.Max_echelon_fund, siteX + siteWidth, siteY);
			}
		} else {
			ctx.fillStyle = Configure.line_color;
			ctx.fillText('0', siteX + siteWidth - 10, siteY + siteHeight * (1- winFactor));
			ctx.fillText(Configure.MAX_BEILI + '%', siteX + siteWidth - 20, siteY);
		}
		ctx.stroke(); 
	};

	var drawEmotionCycle = function(emotions, curEmotion) { 
		var ctx = drawing.getContext("2d");		
		ctx.beginPath();
		
		var center = Math.floor(emotions.length/2);
		for(var i = 0; i < emotions.length; i ++) {
			var xLv = i-center < 0 ? 0 : 1;
			var yLv = i-center >= 0 ?  Math.abs(i-center) + 0.5 :  Math.abs(i-center);
		//	console.log('x = ' + xLv + '  y = ' + yLv);
			var x = siteX + siteWidth + 15 * xLv;
			var y = siteY + 5 + 30 * yLv;
			var txt = '';
			if(emotions[i] == curEmotion) {
				ctx.beginPath();
				ctx.font="bold 16px 楷体";
				ctx.fillStyle = 'red';
				txt = curEmotion + (xLv == 0 ? '  <' : '<');
			} else {
				ctx.font="bold 14px 楷体";
				ctx.fillStyle = 'grey';
				txt = emotions[i];
			}
			ctx.fillText(txt, x, y);
			ctx.stroke();
		}
	};
	var drawIndicators = function(indecatorName, echelonNames) {
		var ctx = drawing.getContext("2d");		
		ctx.beginPath();
		
		function drawBottom(title, maxOffset) {
			var rectHeight = Days[i][title] ? 
						siteHeight * winFactor * parseFloat(Days[i][title]) /maxOffset : 0;
			var rect = {x: siteX + cellWidth  * i,
						y: siteY + siteHeight - rectHeight,
						width: cellWidth*0.9,
						height: rectHeight};
			var grd=ctx.createLinearGradient(rect.x, rect.y + + siteHeight * winFactor * 0.5, 
											rect.x, rect.y);
			if(parseFloat(Days[i][title]) < maxOffset/3) {
				grd.addColorStop(0,"yellow");
				grd.addColorStop(1,"green");
			} else {
				grd.addColorStop(0,"orange");
				grd.addColorStop(1,"red");
			} 
			ctx.fillStyle=grd;
			ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
			if (i == Days.length - 1) {
				ctx.font="14px 楷体";
				ctx.fillText(parseFloat(Days[i][title]), rect.x + 5, rect.y - 10);
			}
			ctx.font="14px 楷体";
			ctx.fillStyle = Configure.line_color;
			ctx.fillText('0', siteX - 20, siteY + siteHeight + 10);
			ctx.fillText(maxOffset, siteX - 30, siteY + siteHeight * (1- winFactor) + 10);
			ctx.stroke();
		}
		function drawUp() {
			ctx.fillStyle="black";
			ctx.strokeStyle = "black";
			var pointH = siteHeight * (1-winFactor) * parseFloat(Days[i][Configure.title2.beili])/Configure.MAX_BEILI;
			var point = {x :siteX + cellWidth  * i + 0.5 * cellWidth,
						y: siteY + siteHeight*(1-winFactor) - pointH};	
							
			emotionPoints.push({point:point, value:parseFloat(Days[i][Configure.title2.beili]), 
						date:Days[i][Configure.title2.date]});
							
			grd=ctx.createLinearGradient(siteX, siteY + siteHeight * (1-winFactor), 
												siteX, siteY);
			grd.addColorStop(0,"green");
			grd.addColorStop(0.3,"orange");
			grd.addColorStop(1,Configure.line_color);  
			ctx.fillStyle = grd;
			ctx.strokeStyle = grd;
			if (i < Days.length - 1) {// 不是最后一个点
				var pointNextH = siteHeight * (1-winFactor) * parseFloat(Days[i + 1][Configure.title2.beili])/Configure.MAX_BEILI;
				var pointNext = {x:siteX + cellWidth  * (i + 1) + 0.5 * cellWidth,
								y: siteY + siteHeight*(1-winFactor) - pointNextH};
				ctx.lineWidth="4";
				ctx.moveTo(point.x, point.y);
				ctx.lineTo(pointNext.x, pointNext.y);
				ctx.stroke();
			} else {
				ctx.font="14px 楷体";
				ctx.fillText(parseFloat(Days[i][Configure.title2.beili]) + '%', point.x + 10, point.y);
				ctx.stroke();
			}
		}
		
		function drawLine(color, zero, maxOffset, title, draw = true) {
			var ctx = drawing.getContext("2d");		
			ctx.beginPath();
			ctx.fillStyle= color;
			var pointH = siteHeight * (1-winFactor) * 
				(parseFloat(Days[i][title])- zero)/maxOffset;
			var szPoint = {x: siteX + cellWidth  * i + 0.5 * cellWidth,
					y: siteY + siteHeight*(1-winFactor) - pointH};
			//	ctx.fillRect(szPoint.x, szPoint.y, 2, 2);
			if (echelonNames.length <= 1 && draw) {
				if (i < Days.length - 1) {// 不是最后一个点
					var pointNextH = siteHeight * (1-winFactor) * 
						(parseFloat(Days[i + 1][title]) - zero)/maxOffset;
					var szpointNext = {x:siteX + cellWidth  * (i + 1) + 0.5 * cellWidth,
									y: siteY + siteHeight*(1-winFactor) - pointNextH};
					ctx.lineWidth="2";
					ctx.strokeStyle = color;
					ctx.moveTo(szPoint.x, szPoint.y);
					ctx.lineTo(szpointNext.x, szpointNext.y);
					ctx.stroke();
				} else {
					ctx.font="14px 楷体"
					ctx.fillText(parseFloat(Days[i][title]) + '', szPoint.x, szPoint.y);
					// 写坐标值
					if(title != Configure.title2.failedRate ) {  // failedRate 不写
						ctx.fillText(zero, siteX - 30, siteY + siteHeight * (1- winFactor));
						ctx.fillText(zero + maxOffset, siteX - 30, siteY);
						ctx.stroke();
					}

				}
			}
			return szPoint;
		};
		
		for(i = 0; i < Days.length; i ++) {
			ctx.beginPath();
			if (echelonNames.length == 0) {   // 没有echolon显示底部量能就显示总量能
				Configure.ZHISHU_TITLE == Configure.title2.lianbanzhishu ? 
					drawBottom(Configure.title2.jinji, 100) : drawBottom(Configure.title2.totalFund, 600);
			} 
			if (echelonNames.length <= 1) {
				drawUp();
			}
			
			var point = drawLine(Configure.sz_color, Configure.SZ_zero,
								Configure.SZ_MaxOffset, Configure.title2.sz , 
								indecatorName == '上证指数');
			szPoints.push({point:point, value:parseFloat(Days[i][Configure.title2.sz]),
									 date:Days[i][Configure.title2.date]});
									 
			var point2 = drawLine('#DC143C', 0, 10, Configure.title2.subBeili, 
							indecatorName == '连扳背离');
			stEmotionPoints.push({point:point2, value:parseFloat(Days[i][Configure.title2.subBeili]),
									 date:Days[i][Configure.title2.date]});
									 
			drawLine('blue', 900, 100, Configure.title2.qingxuzhishu, '情绪指数' == indecatorName );
			drawLine('green', 0, 1, Configure.title2.failedRate, /*'亏钱效应' == indecatorName &&*/ echelonNames.length == 0);
		
			
			switch(indecatorName) {
				case '连扳晋级':
					drawLine('blue', 0, 100, Configure.title2.jinji, '连扳晋级' == indecatorName);
					break;
				case '短线资金':
					drawLine('blue', 100, 400, Configure.title2.totalFund, '短线资金' == indecatorName);
					break;
				case '情绪指数':
					break;
				case '亏钱效应':
					break;
				case '上证指数':
					break;
				case '连扳背离':
					break;
				case '连扳高度':
					//画连扳高度
					point = drawLine(Configure.boardHeight_color, Configure.BH_zero,
								Configure.BH_MaxOffset, Configure.BH_Draw_title);
					if (i < Days.length - 1 && i > 0 && Days[i][Configure.title2.dragon] &&
					   Days[i][Configure.BH_Draw_title] >= Days[i+1][Configure.BH_Draw_title] &&
					   Days[i][Configure.BH_Draw_title] > Days[i-1][Configure.BH_Draw_title]) {    // 只写最高点的名字
						ctx.fillText(Days[i][Configure.title2.dragon].substr(0,2) + '', point.x - 10, point.y - 5);
						ctx.stroke();
					}
					break;
				case '连扳数量':
					drawLine(Configure.boardHeight_color, 5, 10, Configure.title2.lianban);
					break;
				case '涨停数量':
					drawLine(Configure.boardHeight_color, 30, 40, Configure.title2.boardnum);
					break;
				case '跌停数量':
					drawLine('#20B2AA', 0, 15, Configure.title2.floornum);
					break;
				case '炸板数量':
					drawLine('#20B2AA', 0, 20, Configure.title2.failednum);
					break;
				default:
					break;
			}

		};
		ctx.stroke();
	};
	
	var drawEchelon = function(echelonNames) {
		var ctx = drawing.getContext("2d");		
		function calPointHeight(g) {
			return Configure.Echelons_show_type == 'score' ? 
				siteHeight * (1-winFactor) * parseFloat(g[Configure.Echelons_show_type] - Configure.Min_echelon_score)
						/ Configure.Max_echelon_score  : 
				siteHeight * (1-winFactor) * parseFloat(g[Configure.Echelons_show_type] - Configure.Min_echelon_fund)
						/ Configure.Max_echelon_fund;
		}
		
		function drawBottom(bund, maxOffset) {
			var rectHeight = bund ? 
						siteHeight * winFactor * parseFloat(bund) /maxOffset : 0;
			var rect = {x: siteX + cellWidth  * i,
						y: siteY + siteHeight - rectHeight,
						width: cellWidth*0.9,
						height: rectHeight};
			var grd=ctx.createLinearGradient(rect.x, rect.y + + siteHeight * winFactor * 0.5, 
											rect.x, rect.y);
			if(parseFloat(bund) < maxOffset/3) {
				grd.addColorStop(0,"yellow");
				grd.addColorStop(1,"green");
			} else {
				grd.addColorStop(0,"orange");
				grd.addColorStop(1,"red");
			} 
			ctx.fillStyle=grd;
			ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
			if (i == Days.length - 1) {
				ctx.font="14px 楷体";
				ctx.fillText(parseFloat(bund), rect.x + 5, rect.y - 10);
			}
			ctx.font="14px 楷体";
			ctx.fillStyle = Configure.line_color;
			ctx.fillText('0', siteX - 20, siteY + siteHeight + 10);
			ctx.fillText(maxOffset, siteX - 30, siteY + siteHeight * (1- winFactor) + 10);
			ctx.stroke();
		}
		
		var bottomData = 0;
		for(i = 0; i < Days.length; i ++) {
			var echelonArr = Days[i][Configure.title2.echelons];
			echelonArr.forEach((g)=> {    //  g : {name:'', hotPoints:[], score:'', fund:''};
				if(echelonNames.indexOf(g.name) != -1) {
					var drawNameDone = false;	
					var pointH =  calPointHeight(g);
					// 记录底部数据
					bottomData = Configure.Echelons_show_type == 'score' ? g.fund : g.score;
					/////
					var point = {x :siteX + cellWidth  * i + 0.5 * cellWidth,
							y: siteY + siteHeight*(1-winFactor) - pointH};	
							
					var color = Configure.echelon_color[echelonNames.indexOf(g.name)%Configure.echelon_color.length];
								
					if (i < Days.length - 1) {   // 不是最后一天
						var echelonsNext = Days[i+1][Configure.title2.echelons];
						
						echelonsNext.forEach((gNext)=>{
							if (gNext.name == g.name){
								var pointNextH = calPointHeight(gNext);
								var pointNext = {x:siteX + cellWidth  * (i + 1) + 0.5 * cellWidth,
													y: siteY + siteHeight*(1-winFactor) - pointNextH};
								ctx.beginPath();
								ctx.lineWidth="3";
								ctx.strokeStyle = color;
								ctx.moveTo(point.x, point.y);
								ctx.lineTo(pointNext.x, pointNext.y);
								ctx.stroke();
								drawNameDone = true;
							}
						});
					}
					if (!drawNameDone && i == Days.length - 1) {  // 没有连线，画名称
						drawNameDone = true;
						ctx.beginPath();
						ctx.fillStyle= color;
						ctx.font="14px 楷体";
						ctx.fillText(g.name + g[Configure.Echelons_show_type] , point.x + 5, point.y);
						ctx.stroke();
					};
				}
			});
			if (bottomData != 0) {
				drawBottom(bottomData, 200);
			}
		};
	};
	// type = Configure.title2.lianbanzhishu  or Configure.title2.zhangtingzhishu
	var getLastEmotionPoints = function(num, type = Configure.title2.lianbanzhishu) {
		var ePoints = type == Configure.ZHISHU_TITLE ? emotionPoints : stEmotionPoints;
		var n = num > ePoints.length ? ePoints.length : num;
		var retP = [];
		for(var i = ePoints.length - 1; i > ePoints.length - 1 - n; i --) {
			retP.push(ePoints[i]);
		}
		return retP;
	};
	
	var getLastSZPoints = function(num) {
		var n = num > szPoints.length ? szPoints.length : num;
		var retP = [];
		for(var i = szPoints.length - 1; i > szPoints.length - 1 - n; i --) {
			retP.push(szPoints[i]);
		}
		return retP;
	};
	
	var draw = function(echelonNames, indecatorName) {
		if (drawing.getContext){
			var ctx = drawing.getContext("2d");
			ctx.clearRect(0, 0, width, height);
			
			//cut Days to display
			var tmplengh = Days.length > Configure.Days_Max_lengh ? Configure.Days_Max_Show_lengh : 
						Days.length - (Configure.Days_Max_lengh - Configure.Days_Max_Show_lengh);
			Days = Days.slice(Days.length - tmplengh, Days.length);
			drawSite(indecatorName, echelonNames);
			drawIndicators(indecatorName, echelonNames);
			drawEchelon(echelonNames);
		}
	}
	
	return {
		init: init,
		draw: draw,
		drawEmotionCycle:drawEmotionCycle,
		getLastEmotionPoints:getLastEmotionPoints,
		getLastSZPoints:getLastSZPoints
	}
})();
